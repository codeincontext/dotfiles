" --- Core ---

" Necesary for lots of cool vim things
set nocompatible

" This shows what you are typing as a command.
set showcmd

" Needed for Syntax Highlighting and stuff
filetype on
filetype plugin on
syntax enable
set grepprg=grep\ -nH\ $*

" Who doesn't like autoindent?
set autoindent

" Spaces > tabs
set expandtab
set smarttab

" 2 spaces > 8 spaces
set shiftwidth=2
set softtabstop=2

" Got backspace?
set backspace=2

" show line at 80 chars
set tw=80

" Column width indicator
set colorcolumn=+1

" Ignore case in searches etc
set ignorecase

" Don't ignore case if the search string has uppercase letters
set smartcase

" fixes a compatability thing with the escape key, or something
set noesckeys

" highlight trailing spaces
set list listchars=tab:\ \ ,trail:·

" Incremental searching
set incsearch

" Highlight search results
" set hlsearch

" Highlight matching parenthesis
highlight MatchParen ctermbg=4


" always display status line
set laststatus=2
" set statusline=%F%m%r%h%w\ (%{&ff}){%Y}\ [%l,%v][%p%%]

syntax on
filetype off                   " required!


" Setting both relativenumber and number enables a hybrid line number mode as of Vim 7.4
set relativenumber
set number

" stop annoying messages when opening the same file twice etc. we're in 2013,
" my mac doesn't randomly crash
set noswapfile
set nobackup
set nowritebackup
set autoread

" Minimal number of screen lines to keep above and below the cursor
set scrolloff=3

" No need to show mode
set noshowmode

" reload vimrc if changed
augroup myvimrc
    au!
    au BufWritePost .vimrc,_vimrc,vimrc,.gvimrc,_gvimrc,gvimrc so $MYVIMRC | if has('gui_running') | endif
augroup END

" --- Colours ---

set background=dark
set term=screen-256color

colorscheme Tomorrow-Night

if has("gui_running")
  " Remove Toolbar
  set guioptions-=T

  set guifont=Source\ Code\ Pro\ for\ Powerline:h14
endif

" --- Mappings ---

" make Y yank to end of line (like it should do)
nmap Y y$

" don't yank the replaced text when pasting in visual mode
vnoremap p "_dP

" Remap backtick to esc using KeyRemap4Macbook
" Trust me, backtick is an amazing key for this
"   
"     <item>
"       <name>Map backtick to esc, shift+backtick to backtick</name>
"       <identifier>private.map_backtick_to_esc</identifier>
"       <autogen>__KeyToKey__ KeyCode::BACKQUOTE, MODIFIERFLAG_EITHER_LEFT_OR_RIGHT_SHIFT, KeyCode::BACKQUOTE</autogen>
"       <autogen>__KeyToKey__ KeyCode::BACKQUOTE, KeyCode::ESCAPE</autogen>
"     </item>

" paste something on a new line
:nmap <leader>p o<ESC>p

" little hack to prevent me from moving about in insert mode
" so I can get used to vim navigation
inoremap <Left>  <NOP>
inoremap <Right> <NOP>
inoremap <Up>    <NOP>
inoremap <Down>  <NOP>

" --- tmux ---

function! TmuxPaneJumpForKey(key)
  " defines the window to jump to based on the number of windows and the key pressed
  " 1st row: 1 window open. 2nd row: 2 windows. 3rd row: 3 windows
  let l:key_to_window_mapping = [
  \   {},
  \   { "u": 1, "o": 2, },
  \   { "u": 1, "i": 2, "o": 3, },
  \ ]

  " temporarily dismiss syntastic errors list (interferes with pane count)
  lclose

  let l:max_win_count = len(l:key_to_window_mapping)
  let l:win_count = min([winnr('$'), l:max_win_count])
  let l:mapping_for_win_count = l:key_to_window_mapping[l:win_count - 1]

  if (has_key(l:mapping_for_win_count, a:key))
    :call s:JumpToWindow(l:mapping_for_win_count[a:key])
  endif
endfunction

function! s:JumpToWindow(new_window)
  if (a:new_window !=# winnr())
    execute a:new_window . "wincmd w"
  endif
endfunction

let previous_title = substitute(system("tmux display-message -p '#{pane_title}'"), '\n', '', '')
let &t_ti = "\<Esc>]2;vim\<Esc>\\" . &t_ti
let &t_te = "\<Esc>]2;". previous_title . "\<Esc>\\" . &t_te

:map <silent> <C-O> :call TmuxPaneJumpForKey('o')<CR>
:map <silent> <C-I> :call TmuxPaneJumpForKey('i')<CR>
:map <silent> <C-U> :call TmuxPaneJumpForKey('u')<CR>

:imap <C-O> <Esc><C-O>
:imap <C-I> <Esc><C-I>
:imap <C-U> <Esc><C-U>


" --- Plugins ---

" Vundle is ace, and pulls in plugins from git repos
set rtp+=~/.vim/bundle/vundle/
call vundle#rc()

" let Vundle manage Vundle
Bundle 'gmarik/vundle'
" Automatic completion for variable names, etc. It's 90% there, but there
" might be a better alternative
Bundle 'Valloric/YouCompleteMe'

" like 'f', but accepts two letters. eg: 'sth' to jump to 'the'
Bundle 'justinmk/vim-sneak'

Bundle 'tpope/vim-surround'
" Normal mode
" -----------
" ds  - delete a surrounding
" cs  - change a surrounding

" ys  - add a surrounding
" yS  - add a surrounding and place the surrounded text on a new line + indent it
" yss - add a surrounding to the whole line
" ySs - add a surrounding to the whole line, place it on a new line + indent it
" ySS - same as ySs
"
" Visual mode
" -----------
" s   - in visual mode, add a surrounding
" S   - in visual mode, add a surrounding but place text on new line + indent it

" cs "'     change surround from " to '
" ds ' to delete ' quotes
" nmap <leader>SS   <Plug>YSsurround " surround current line and put on new line
" nmap <leader>ss   <Plug>Yssurround " surround current line
" nmap <leader>S    <Plug>YSurround " surround selection and put on new line
" nmap <leader>s    <Plug>Ysurround " surround selection


" nmap ds  <Plug>Dsurround
" nmap cs  <Plug>Csurround
" nmap ys  <Plug>Ysurround
" nmap yS  <Plug>YSurround
" nmap yss <Plug>Yssurround
" nmap ySs <Plug>YSsurround
" nmap ySS <Plug>YSsurround
" xmap S   <Plug>VSurround
" xmap gS  <Plug>VgSurround
"
" Commenting plugin. gcc to toggle comments on current line. gc{motion} to
" toggle comments over a selection
Bundle 'tomtom/tcomment_vim'

" Sidebar showing the project directory. Not 100% clued up on this bit - might
" need to tweak my workflow
Bundle 'scrooloose/nerdtree'

" bind nerdtree to ctrl-n
map <C-n> :NERDTreeToggle<CR>

" open nerdtree on load if it's a directory
if isdirectory(argv(0))
    bd
    autocmd vimenter * exe "cd" argv(0)
    autocmd VimEnter * NERDTree
endif

" Close if the only thing left is nerdtree
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif


" UltiSnips brings textmate-like snippets to vim. I haven't set any up yet, but
" in textmate it saved me a load of time shortening console.log(???) to cl and
" function(?,?) {?} to fn - things like that
Bundle 'SirVer/ultisnips'

let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"

" Make UltiSnips works nicely with YCM
function! g:UltiSnips_Complete()
  call UltiSnips#ExpandSnippet()
  if g:ulti_expand_res == 0
    if pumvisible()
      return "\<C-n>"
    else
      call UltiSnips#JumpForwards()
      if g:ulti_jump_forwards_res == 0
        return "\<TAB>"
      endif
    endif
  endif
  return ""
endfunction

au BufEnter * exec "inoremap <silent> " . g:UltiSnipsExpandTrigger . " <C-R>=g:UltiSnips_Complete()<cr>"


Bundle 'honza/vim-snippets'

" This opens up ruby blocks to the manipulations you can get between brackets
" and braces in other languages.
" Where ci{ changes the contents of curly braces, cir will change the contents
" of the current ruby block, if statement, method or class
Bundle "textobj-user"
Bundle "textobj-rubyblock"

" Lints code as you write it. Doesn't get in the way, but will highlight
" issues
Bundle "scrooloose/syntastic"

let g:syntastic_javascript_checkers = ['jsl']
let g:syntastic_javascript_jsl_conf = "--es5"
let g:syntastic_error_symbol="✗"
let g:syntastic_warning_symbol="⚠"
let g:syntastic_style_error_symbol="s✗"
let g:syntastic_style_warning_symbol="s⚠"
let g:syntastic_auto_jump=0
let g:syntastic_auto_loc_list=1
let g:syntastic_loc_list_height=3

let g:syntastic_elixir_checkers = []
filetype plugin indent on

" This does a load of stuff
Bundle 'tpope/vim-rails'

" status line
Bundle 'bling/vim-airline'
let g:airline_powerline_fonts = 1
let g:airline_section_x = airline#section#create_right(['tagbar']) " does this work? maybe just remove it for airline-outline
let g:airline_section_y = airline#section#create_right(['filetype'])

let g:airline#extensions#whitespace#enabled = 0


" fugitive is a git wrapper. I don't use it as much as I should, but it's used
" by other plugins
Bundle "tpope/vim-fugitive"


Bundle "elixir-lang/vim-elixir"
Bundle 'jelera/vim-javascript-syntax'


" determines class/variable/function names in the file
" to display on request, or to show in the statusbar
Bundle "majutsushi/tagbar"
nnoremap <silent> <c-t> :TagbarToggle<CR>

" Needed for Unite's async
Bundle "Shougo/vimproc.vim"

" Unite is a fuzzy finder for files, buffers, etc
Bundle "Shougo/unite.vim"
Bundle "Shougo/unite-outline"
Bundle "Shougo/neomru.vim"

" Unite
let g:unite_source_history_yank_enable = 1
let g:unite_source_grep_command = 'ag'
let g:unite_source_grep_default_opts = '--nocolor --nogroup --column'
let g:unite_source_grep_recursive_opt = ''
let g:unite_source_rec_async_command= 'ag --nocolor --nogroup --hidden -g ""'


call unite#filters#matcher_default#use(['matcher_fuzzy'])
call unite#filters#sorter_default#use(['sorter_selecta']) " or sorter_rank

" call unite#custom_source('file_rec,file_rec/async,file,grep', 'sorter', 'sorter_selecta')

let g:unite_enable_start_insert = 1

nnoremap [unite] <Nop>
nmap <space> [unite]

" should investigate git grep unite filter
nnoremap [unite]t :<C-U>Unite -no-split -buffer-name=files   file_rec/async:!<CR>
nnoremap [unite]f :<C-u>Unite -no-split -buffer-name=files   file<cr>
nnoremap [unite]r :<C-u>Unite -no-split -buffer-name=mru     file_mru<cr>
nnoremap [unite]o :<C-u>Unite -no-split -buffer-name=outline outline<cr>
nnoremap [unite]y :<C-u>Unite -no-split -buffer-name=yank    history/yank<cr>
nnoremap [unite]b :<C-u>Unite -no-split -buffer-name=buffer  buffer<cr>
nnoremap [unite]j :<C-u>Unite -no-split -buffer-name=jump    jump<cr>
nnoremap [unite]g :<C-u>Unite -buffer-name=grep              grep:.<cr>
nnoremap [unite]G :<C-u>Unite -buffer-name=grep -resume      grep:.<cr>
nnoremap [unite]d :<C-u>Unite -no-split -buffer-name=TODO    grep:.:-s:\(TODO\|FIXME\)<cr>

autocmd FileType unite call s:unite_my_settings()
function! s:unite_my_settings()"{{{
  nmap <buffer> <C-s>      <Plug>(unite_redraw)
endfunction"}}}


" Set up some custom ignores
call unite#custom_source('file_rec,file_rec/async,file_mru,file,buffer,grep',
      \ 'ignore_pattern', join([
      \ '\.git/',
      \ 'tmp/',
      \ '.sass-cache',
      \ 'node_modules/',
      \ 'bower_components/',
      \ '\.png',
      \ '\.svg',
      \ '\.gif',
      \ '\.bmp',
      \ '\.jpg',
      \ '\.sql',
      \ 'log/'
      \ ], '\|'))

" remove limits
call unite#custom_source('file_rec,file_rec/async,file,grep', 'max_candidates', 0)
let g:unite_source_rec_max_cache_files = 0

" buffer is for quick jumps to recent files. 10 candidates means quick filtering
call unite#custom_source('buffer', 'max_candidates', 10)

" MRU is for finding a file that has been edited in the last few weeks
call unite#custom_source('file_mru', 'max_candidates', 50)

" don't sort by selecta for recency searches that have an implicit order
" not working atm
" call unite#custom_source('buffer,file_mru', 'sorter', 'sorter_default')

Bundle 'skattyadz/charlie.vim'
let g:charlie_split_here_key = 'K'

Bundle 'rizzatti/dash.vim'
:nmap <silent> <leader>D <Plug>DashGlobalSearch
:nmap <silent> <leader>d <Plug>DashSearch

Bundle 'bkad/CamelCaseMotion'
xmap  <leader>ie    <Plug>CamelCaseMotion_ie
omap  <leader>ie    <Plug>CamelCaseMotion_ie
xmap  <leader>ib    <Plug>CamelCaseMotion_ib
omap  <leader>ib    <Plug>CamelCaseMotion_ib
xmap  <leader>iw    <Plug>CamelCaseMotion_iw
omap  <leader>iw    <Plug>CamelCaseMotion_iw
map   <leader>e     <Plug>CamelCaseMotion_e
map   <leader>b     <Plug>CamelCaseMotion_b
map   <leader>w     <Plug>CamelCaseMotion_w

Bundle 'tpope/vim-ragtag'

" " " " " " " " "
" MOVING AROUND "
" " " " " " " " "

" { and } allow you to jump between whitespace, which is usually a good
" indicator of 'sections'

" Use {num}j to move between lines if relative line numbers are on.



" " " " " " " "
" NORMAL KEYS "
" " " " " " " "

" a: insert (after)
" b:
" c: change. eg: ci(
" d: delete. eg: df_
" e:
" f: find letter. eg: fr
" g:
" h: left
" i: insert here
" j: down
" k: up
" l: right
" m:
" n: next search occurence
" o: insert line after
" p: paste after
" q:
" r: replace letter
" s: seek for 2 chars in line. eg: sau wil jump to the a in 'sauce'
" t: 'til letter. like f, but jump to letter before
" u:
" v:
" w:
" x: remove char
" y: yank
" z:



" " " " " " " "
" UPCASE KEYS "
" " " " " " " "

" A: insert at end of line
" B:
" C: change to end of line!
" D: delete to end of line!
" E: jump to end of WORD (delineated by whitespace)
" F: find earlier in line
" G:
" H:
" I: insert at start of line
" J:
" K:
" L:
" M:
" N: previous search result
" O: new line above
" P: paste before/above
" Q:
" R:
" S: seek backwards in line
" T: 'til but backwards in line
" U:
" V:
" W: Jump to next WORD (split by whitespace)
" X: delete char behind cursor
" Y:
" Z:


" " " " " " " "
" OTHER KEYS  "
" " " " " " " "
" #
" ~: Switch case of letter
" !
" @
" £
" $
" %
" ^: Jump to beginning of code in line (after indentation)
" &
" *
" (
" )
" -
" _
" =
" +
" [
" ]
" {
" }
" ;
" :
" '
" "
" \
" |
" `
" ,
" .
" <
" >
" /
" ?
